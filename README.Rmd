---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```


# dimmodelR

<!-- badges: start -->
<!-- badges: end -->

Business-intelligence tools such as Power BI, Tableau and Qlik work best when 
data are organized as a [dimensional model](https://en.wikipedia.org/wiki/Dimensional_modeling).
A common task within business intelligence is therefore to transform source data 
according to this model's underlying design principle known as 
[star schema](https://en.wikipedia.org/wiki/Star_schema).

The `dimmodelR` package makes this easy using R. It provides a set of functions 
for automating the process of creating and refreshing a central data model 
consisting of multiple [fact tables](https://en.wikipedia.org/wiki/Fact_table) 
and a set of shared [dimensions](https://en.wikipedia.org/wiki/Dimension_(data_warehouse)#Dimension_table).


## Installation

You can install the development version of dimmodelR from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("cvermehren/dimmodelR")
```

## Workflow

The following workflow is supported:

1. Define a star-schema model from one or more data frames
2. Populate the model with data and set up incremental refresh
4. Save the model as csv or parquet files and serve them to a BI tool


## Define a star-schema model

A star-schema model can be based on multiple data frames, but needs to be built 
gradually. We will start with the included demo dataset `campaign_metrics`:

```{r, eval=T}
library(dimmodelR)

data(campaign_metrics)

str(campaign_metrics)
```

Typically fact tables are formed by numerical columns, while dimensions are 
formed by character columns.

To define a star-schema model we only need to specify the dimensions. Fact 
tables will be added later when we populate the model with data.

```{r, eval=T}
# Define dimensions
dimensions = list(dim_channel = c("source", "medium", "campaign"))

# Initiate the model
dm <- dm_model(campaign_metrics, dimensions)

str(dm)
```

The function `dm_model` has extracted one dimension, `dim_channel`, from the 
data frame and added a [surrogate key](https://en.wikipedia.org/wiki/Surrogate_key) 
column named `channel_key`. 

The surrogate key will function as the [primary key](https://en.wikipedia.org/wiki/Primary_key) 
of `dim_channel` which will reference a [foreign key](https://en.wikipedia.org/wiki/Foreign_key) 
in the fact table when we populate the model with data.

Before we do so, let's extend the model with a few more dimensions.

```{r, eval=T}
data("web_metrics")

str(web_metrics)

```

The `web_metrics` dataset introduces two new dimension columns: `view_name` and 
`country`. These can be added to the model as long as we remember to use the 
model itself (`dm`) as an argument in the function.

```{r, eval=T}
dimensions = list(
  dim_channel = c("source", "medium", "campaign"),
  dim_market = c("view_name", "country")
)

# Extend the model using the model itself `dm` as an argument
dm <- dm_model(web_metrics, dimensions, dm)

str(dm)
```

The model now consist of two dimensions. Let's add one more using the final demo 
dataset.

```{r, eval=T}
data("email_metrics")

dimensions = list(dim_email = c("email"))

dm <- dm_model(email_metrics, dimensions, dm)

str(dm)
```


## Populate the model with data

We now have a dimensional model consisting of three dimensions, but no facts. To
populate the model with facts, we simply pass the model and the original data 
frames to the function `dm_refresh`.


```{r, eval=T}
# Specify the data frames which the model was built from
facts <- list(
  fct_email = email_metrics, 
  fct_campaign = campaign_metrics,
  fct_web = web_metrics
)

# Populate the model with data
dm <- dm_refresh(dm, facts)

str(dm)
```
The model now contains all the data from the three data frames (the source data) 
organized as a dimensional model. 

Notice how the refresh function has added not only three fact tables, but also 
new rows to the dimensions. The reason is that the initial model was based only 
on a sample of source data. When adding the entire datasets using the refresh 
function, the dimensions are updated with rows new to the model.

Notice also how the function handles shared dimension. Two of the fact tables 
(`fct_campaign` and `fct_web`) share the `dim_channel` dimension. In other words, 
the function inserts this dimension's primary key (`channel_key`) into both of 
these fact tables. It automatically identifies how to do so by comparing source 
data and the existing dimensions in the model.

To save the result as csv files:

```{r, eval=F}
dm_write_csv(dm, "my-folder")
 
list.files(path = "my-folder", recursive = TRUE)

```

The `dm_write_csv` function saves the result in two sub-directories `dimensions` 
and `fact_tables`. It will always overwrite the files and, therefore, is not 
meant for incremental refresh.


## Incremental refresh

To refresh your model incrementally, simply feed the model with the newest 
source data followed by `dm_write_parquet`.

Let's simulate how this would work.

```{r, eval=F}

# Load demo data
data("web_metrics")
data("campaign_metrics")
data("email_metrics")

# Ad partitioning columns
web_metrics$month <- lubridate::month(web_metrics$date)
campaign_metrics$month <- lubridate::month(campaign_metrics$date)
email_metrics$month <- lubridate::month(email_metrics$date)

# Create campaig_metrics model
dimensions <- list(dim_channel = c("source", "medium", "campaign"))
dm <- dm_model(campaign_metrics, dimensions)

# Extend model with web_metrics
dimensions <- list(
  dim_channel = c("source", "medium", "campaign"), 
  dim_market = c("view_name", "country"))
dm <- dm_model(web_metrics, dimensions, dm)

# Extend model with email_metrics
dimensions <- list(dim_channel = c("email"))
dm <- dm_model(email_metrics, dimensions, dm)

# Make looping-list for incremental refresh
months <- sort(unique(web_metrics$month))

# Simulate incremental refresh
for (i in months) {
  new_campaign_metrics <- campaign_metrics[which(campaign_metrics$month == i),]
  new_web_metrics <- web_metrics[which(web_metrics$month == i),]
  new_email_metrics <- email_metrics[which(email_metrics$month == i),]
  
  facts <- list(
    fct_campaign = new_campaign_metrics,
    fct_web = new_web_metrics,
    fct_email = new_email_metrics
    )
  
  dm <- dm_refresh(dm, facts)
  
  dm_write_parquet(dm,path = "my-incremental-model", partitioning = c("month"))
}

list.files(path = "my-incremental-model", recursive = TRUE)
```


## Example

This is a basic example which shows you how to solve a common problem:

```{r, eval=T}
library(dimmodelR)
1+2
## basic example code
```



## Features

* Transform a data frame into a [star schema](https://en.wikipedia.org/wiki/Star_schema) 
  with dimensions and fact tables related by [surrogate keys](https://en.wikipedia.org/wiki/Surrogate_key)
* Extend a star schema with more transformations turning it into a central model also known as 
  [fact constellation](https://en.wikipedia.org/wiki/Fact_constellation)
* Easily refresh a central model incrementally as new source data become available
* Save the model as csv or parquet files in a practical predefined folder structure



# dimmodelR

<!-- badges: start -->
<!-- badges: end -->

The goal of dimmodelR is to ...

## Installation

You can install the development version of dimmodelR from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("cvermehren/dimmodelR")
```

## Example

This is a basic example which shows you how to solve a common problem:

```{r example}
library(dimmodelR)
## basic example code
```

What is special about using `README.Rmd` instead of just `README.md`? You can include R chunks like so:

```{r cars}
summary(cars)
```

You'll still need to render `README.Rmd` regularly, to keep `README.md` up-to-date. `devtools::build_readme()` is handy for this. You could also use GitHub Actions to re-render `README.Rmd` every time you push. An example workflow can be found here: <https://github.com/r-lib/actions/tree/v1/examples>.

You can also embed plots, for example:

```{r pressure, echo = FALSE}
#plot(pressure)
```

In that case, don't forget to commit and push the resulting figure files, so they display on GitHub and CRAN.
